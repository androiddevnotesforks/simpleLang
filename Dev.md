# CodeGen
CodeGen 用来生成 llvm 代码，CodeGen::type 是 llvm 类型，但和生成的 llvm::Value 有区别，type 可以能是整数、浮点、结构，但返回 Value 固定为指针。

# 对象的数据结构

  4字节引用计数 *
  4字节队列长度（如果是队列）*
  1字节标志 + 7字节类型

标志定义
0~7 位：

	0	是否数组，如果是数组，上面有长度字段
	1	是否具有引用计数（没引用计数的话，需要手工释放）
	4	是否有符号
	5	是否指针 （ 一般在 interface 的成员变量，都保存指针）
	6	是否是接口
	7	是否默认类型
	其他保留

如果是默认类型，类型为:
	
	| 0 | String 字符串
	| 1 | boolean	  
	| 2 | byte	    
	| 3 | char	    
	| 4 | short		
	| 5 | int		
	| 6 | long		
	| 7 | float		
	| 8 | double	
	| 9 | Any
	| 10 | Delay
	| 11 | Func 函数指针
	| 12 | Thread
	
* 对象数据

# 对 c 的兼容

在语法层面去除了下划线在函数、变量中的使用，这样它就可以用来当分割符了，以便 c 函数导入。

模块分两种，Si 模块——以源码的形式导入，c 模块——以 llvm ir + dll 的形式导入。
如果没有模板，Si 模块也可以编译为 c 模块。

语法层面规定类必须大写开头，函数（成员函数）、变量必须以小写开头，既保证了风格统一，也帮助语法分析器可以分析 < M > 是否是模板，并且 C 语言中也可以使用 _ 和大小写搞定映射。

llvm ir 中的 struct 被映射为类，而静态函数被映射为 {类全名} _ S_ 函数 _ 后缀。
由于 ir 中 struct 的成员不存在名称，
因此成员变量的读写全部映射为 {类全名} _ {SET/GET} _ {index} _ {变量名}。
这样通过 llvm struct 和对应的 SET，GET 函数，就能完全映射类。

静态变量被映射为全局变量，_{类全名} _ {name}。

# 类继承

class MyClass : Base

在 llvm IR 中， MyClass 作为 Base 的扩展类型（前几个字段是 Base）的类型，Interface 作为模板约束，在 llvm IR 中被抛弃，由于不需要虚表什么的，可以直接使用指针把 MyClass 赋值给 Base.
如果需要 dycast, 那么需要读取头字节中的类型，然后判断是否可以转换（运行期）。

编译的时候，需要保存一份继承表，用来判断是否可以赋值和动态转换。

# 字符串

字符串编译时转换为 unicode，表情符号占用2个字符。

# 类

源码级别的类使用 AstClass 保持，实例化以后，确定了模板类参数，使用 ClassInstance 保存。
ClassInstanceType 在 new 一个 AstClass 的时候生成，因为这个时候可以确定模板参数，然后用指定类型构造 llvm Type。
ClassInstanceType 内的成员函数，有可能还是模板的，因此保存为 AstFunction, 在函数被调用的时候才实例化。

包导入的时候，定义一般为源码级导入，具体 c 函数，被包装为 FunctionInstance 后，再反包装为 AstFunction 放回。

函数调用的时候，使用 名字 + 类型 的方式查找 c 函数，如果找到，优先调用 c 函数，如果找不到，尝试使用源码。                              
							  
# 上下文 Context

上下文有几种情况
# 上下文
## 全局
最外层的上下文环境

## 全局函数

在全局环境中，注入函数参数
函数内的上下文为函数自身 + 定义函数时的上下文（一般应该是全局）

## 类内
在类定义环境中，注入 this, 这个 this 由函数首个参数传入
类内上下文是类自身上下文 + 定义函数时的上下文（一般应该是全局）

    在全局环境中，注入类内静态变量，另外，考虑到下面的写法
    class My{
		func in()
		var x=in() 
	}
	还要注入方法。

## 成员函数上下文
成员函数上下文为成员函数自身 + 类上下文

## 类实例 ( obj.val 这种 )
	在类定义环境中，额外注入 this，这个 this 为对象实例

# 逃逸分析
## 区域变量逃逸分析
SiLang 需要在编译期进行逃逸分析以优化性能。  
我们以函数为单位进行逃逸分析，首先分析函数内变量是否会被返回，如果会，标记内部变量为“会逃逸”

	func myFunc( ) {
		MyCls a()		// a 创建为引用计数1		
		return a		// a 会逃逸
	}

当变量被整体赋值（引用）时标记为会逃逸

	func myFunc( Cls x ) {
		MyCls a()
		x.a = a  		// a 会逃逸
	}

变量被用于线程内，被标记为会逃逸

	func myFunc(){
		MyCls a()
		go {
			a	// 逃逸
		}
	}

## 参数逃逸分析
除了返回外，其他等同区域变量逃逸分析
非逃逸参数，标记为 const 的

	func MyFunc( MyCls a ){	// a 被标记为 const (不会逃逸)
		.. 
	}

## 组合
当变量被作为参数传入一个函数，如果这个函数表示参数是 const 的，那么不改变这个变量的逃逸性，否则标记它为会逃逸。

## 构造
非逃逸变量使用堆构造 (llvm 的 alloc)。逃逸变量默认使用 createObject 构造为标准对象，使用 GC 管理，未来如果类被声明为手工管理，对象使用 malloc 构造。

## 析构&内存释放
部分 **块（block)** 需要附带一个独立的释放块，并包含独立的释放堆栈，这包括函数块，分支块，协程块。这是由于执行路径不一致，释放栈是不一样的。

逃逸对象构造的时候引用计数1，并在放入释放堆栈，在当前块结束的时候，跳转到对应的释放块，调用 release。

逃逸变量在作为会逃逸参数被调用时，引用计数+1，被协程块引用时引用计数+1，被作为成员函数引用时引用计数+1，其他时候不需要。

几个特殊情况的思考：

new 了以后没被任何参数引用的对象肯定是非逃逸的，可以不用考虑。

考虑到会逃逸的对象 A

	var b = A
	var c = b
	go{ c }

这种情况下，变量 b 实际并不会逃逸，逃逸分析应该可以优化。但考虑到我们语言的定义，c 其实是 b 的别名，是完全一样的，所以应该不会带来多次引用计数加减。

# interface 的实现

interface 一个关键字，但在不同的地方有不同的实现

如果在类型定义上，那么仅仅由编译器检查类是否符合标准，生成代码里并不体现。

	class MyClass : Interface0

如果在函数的参数里，如果函数是带代码的，那么会作为模板参数来实现，以提高性能。

	func myFunc( Interface a ) {}  // a 是模板变量

如果作为变量或者不带代码（二进制实现）的函数，那么实现为一个结构，结构里保存了指针，赋值的时候复制指针。
这个结构还附带原对象的指针和类型，析构函数，以便销毁对象，或者转（cast）回原对象。

	interface MyInterface{
		int value
		func print(){}		// 函数保存为函数指针
	}

	MyInterface v=object	// 这里会把各个成员变量的指针赋值给 v，并引用 object

