# 数据结构

* 4字节引用计数
* 4字节压缩的类型索引，指向类型结构数据的保存地址
	特别的，第一位用来表示是否是数组

* 对象数据

# 对 c 的兼容

在语法层面去除了下划线在函数、变量中的使用，这样它就可以用来当分割符了，以便 c 函数导入。

模块分两种，Si 模块——以源码的形式导入，c 模块——以 llvm ir + dll 的形式导入。
如果没有模板，Si 模块也可以编译为 c 模块。

语法层面规定类必须大写开头，函数（成员函数）、变量必须以小写开头，既保证了风格统一，也帮助语法分析器可以分析 < M > 是否是模板，并且 C 语言中也可以使用 _ 和大小写搞定映射。

llvm ir 中的 struct 被映射为类，而静态函数被映射为 {类全名} _ S_ 函数 _ 后缀。
由于 ir 中 struct 的成员不存在名称，
因此成员变量的读写全部映射为 {类全名} _ {SET/GET} _ {index} _ {变量名}。
这样通过 llvm struct 和对应的 SET，GET 函数，就能完全映射类。

静态变量被映射为全局变量，_{类全名} _ {name}。

# 类继承

class MyClass : Base

在 llvm IR 中， MyClass 作为 Base 的扩展类型（前几个字段是 Base）的类型，Interface 作为模板约束，在 llvm IR 中被抛弃，由于不需要虚表什么的，可以直接使用指针把 MyClass 赋值给 Base.
如果需要 dycast, 那么需要读取头字节中的类型，然后判断是否可以转换（运行期）。

编译的时候，需要保存一份继承表，用来判断是否可以赋值和动态转换。

# 字符串

考虑到效率，字符串只有在必要的情况下才转换到 unicode。而编译器会猜测需要的类型，
在编译的时候就选好编码。

默认的，如果字符串被直接传递到 char\* 类型的参数 （比如 printf），将不进行任何编码转换（使用源文件的编码），并不生成 String 对象。
生成 String 对象的情况下，会转换为 Unicode，表情符号占用2个字符。

# 类

源码级别的类使用 AstClass 保持，实例化以后，确定了模板类参数，使用 ClassInstance 保存。
ClassInstanceType 在 new 一个 AstClass 的时候生成，因为这个时候可以确定模板参数，然后用指定类型构造 llvm Type。
ClassInstanceType 内的成员函数，有可能还是模板的，因此保存为 AstFunction, 在函数被调用的时候才实例化。

包导入的时候，定义一般为源码级导入，具体 c 函数，被包装为 FunctionInstance 后，再反包装为 AstFunction 放回。

函数调用的时候，使用 名字 + 类型 的方式查找 c 函数，如果找到，优先调用 c 函数，如果找不到，尝试使用源码。                              
							  

